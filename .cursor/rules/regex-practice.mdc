# 🔒 Secure Regex Practices

## 🚨 Critical Security Rules

### **NEVER Use These Patterns (ReDoS Vulnerable)**
```ts
// ❌ VULNERABLE - Catastrophic backtracking
/.*#(\d+).*/                    // Can cause exponential runtime
/^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/  // Multiple backtracking issues
/.*\d+.*/                       // Greedy quantifiers with overlapping patterns
/(a+)+/                         // Nested quantifiers (evil regex)
/(a|aa)*/                       // Exponential backtracking
```

### **ALWAYS Use These Secure Alternatives**
```ts
// ✅ SECURE - Linear runtime guaranteed
/#(\d+)/                        // Direct match, no backtracking
/^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/  // Fixed version
/\d+/                           // Simple, direct match
/a+/                            // Single quantifier
/(?:a|aa)*/                     // Non-capturing, optimized
```

## 🎯 Best Practices

### 1. **Avoid Greedy Quantifiers with Overlapping Patterns**
```ts
// ❌ Bad - Can cause backtracking
const badPattern = /.*#\d+.*/;

// ✅ Good - Direct match
const goodPattern = /#\d+/;
```

### 2. **Use Non-Capturing Groups When Possible**
```ts
// ❌ Bad - Capturing group overhead
const badPattern = /(\w+)(\([^)]+\))/;

// ✅ Good - Non-capturing group
const goodPattern = /(\w+)(?:\([^)]+\))/;
```

### 3. **Limit Quantifier Ranges**
```ts
// ❌ Bad - Unbounded range
const badPattern = /\d+/;

// ✅ Good - Bounded range
const goodPattern = /\d{1,10}/;
```

### 4. **Use Anchors to Prevent Unnecessary Matching**
```ts
// ❌ Bad - Can match anywhere in string
const badPattern = /#\d+/;

// ✅ Good - Anchored to start/end
const goodPattern = /^#\d+$/;
```

### 5. **Use Atomic Groups to Prevent Backtracking**
```ts
// ❌ Bad - Can backtrack within group
const badPattern = /(\w+)(\([^)]+\))/;

// ✅ Good - Atomic group prevents backtracking
const goodPattern = /(\w+)(?>\([^)]+\))/;
```

### 6. **Set Execution Timeouts for Regex Operations**
```ts
// ❌ Bad - No timeout protection
const result = regex.test(input);

// ✅ Good - With timeout protection
const result = await Promise.race([
  regex.test(input),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Regex timeout')), 1000)
  )
]);
```

## 🔍 Common Vulnerable Patterns to Avoid

### **Nested Quantifiers (Evil Regex)**
```ts
// ❌ NEVER USE - Exponential runtime
/(a+)+/         // Matches "a", "aa", "aaa", etc.
/(\d+)+/        // Matches "1", "12", "123", etc.
/(\w+)+/        // Matches word characters
```

### **Greedy + Lazy Combinations**
```ts
// ❌ VULNERABLE - Can cause backtracking
/.*\d+?/        // Greedy .* with lazy \d+?
/\w+.*?/        // Greedy \w+ with lazy .*?
```

### **Complex Alternations**
```ts
// ❌ VULNERABLE - Multiple paths can cause backtracking
/(a|aa|aaa|aaaa)*/  // Multiple alternatives with quantifier
```

## 🛡️ Security Checklist

Before using any regex, verify:

- [ ] **No nested quantifiers** like `(a+)+`
- [ ] **No greedy + lazy combinations** like `.*+?`
- [ ] **No overlapping patterns** that can backtrack
- [ ] **Use bounded quantifiers** when possible
- [ ] **Test with malicious input** like repeated characters
- [ ] **Consider input length limits** to prevent DoS
- [ ] **Use atomic groups** `(?>...)` to prevent backtracking
- [ ] **Set execution timeouts** for regex operations
- [ ] **Validate and sanitize input** before processing
- [ ] **Test with edge cases** and various input types

## 🧪 Testing for Vulnerabilities

### **Input Validation and Sanitization**
```ts
// ❌ Bad - No input validation
const processInput = (input: string) => {
  return regex.test(input); // Dangerous!
};

// ✅ Good - With input validation
const processInput = (input: string) => {
  // Validate input length to prevent DoS
  if (input.length > 1000) {
    throw new Error('Input too long');
  }
  
  // Sanitize input to remove potentially dangerous characters
  const sanitized = input.replace(/[^\w\s#]/g, '');
  
  return regex.test(sanitized);
};
```

### **Test with Malicious Input**
```ts
// Test patterns with these inputs to detect ReDoS
const maliciousInputs = [
  'a'.repeat(1000) + 'b',           // Tests (a+)+ patterns
  '#1' + '0'.repeat(1000),          // Tests #\d+ patterns
  'a'.repeat(1000) + '!',           // Tests .* patterns
];

// If any test takes >100ms, the regex is vulnerable
```

### **Use Regex Safety Tools**
```bash
# Install safe-regex for Node.js
npm install safe-regex

# Use in code
import safeRegex from 'safe-regex';
const isSafe = safeRegex(/your-regex-pattern/);
```

## 📚 Safe Regex Examples

### **Conventional Commit Parsing**
```ts
// ❌ VULNERABLE - Original pattern
const badPattern = /^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/;

// ✅ SECURE - Fixed pattern (still needs improvement)
const goodPattern = /^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/;

// 🔒 MOST SECURE - Completely rewritten (based on web research)
const securePattern = /^(feat|fix|docs|style|refactor|test|chore)(\([a-z]+\))?:\s[a-z].{0,72}$/;
```

### **Issue Number Extraction**
```ts
// ❌ VULNERABLE - Original pattern
const badPattern = /.*#(\d+).*/;

// ✅ SECURE - Direct match
const goodPattern = /#(\d+)/;
```

## 🚀 Performance Guidelines

### **Prefer String Methods Over Regex**
```ts
// ❌ Bad - Regex overhead
const hasIssue = /#\d+/.test(message);

// ✅ Good - String method
const hasIssue = message.includes('#');
```

### **Use Regex Only When Necessary**
```ts
// ❌ Bad - Regex for simple check
const isNumber = /^\d+$/.test(input);

// ✅ Good - Built-in method
const isNumber = !isNaN(Number(input)) && input.trim() !== '';
```

## 📖 Resources

- [OWASP ReDoS Prevention](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)
- [Safe Regex Testing](https://github.com/davisjam/safe-regex)
- [Regex Performance](https://www.regular-expressions.info/performance.html)

---

**Remember**: When in doubt, prefer simple string methods over complex regex patterns. Security and performance are more important than elegant regex solutions.
alwaysApply: true
---
