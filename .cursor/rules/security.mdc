---
description: Security best practices and secure coding guidelines
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# 🔒 Security Best Practices

Follow security best practices to protect applications and users from vulnerabilities and attacks.

## 🚨 Critical Security Rules

### **NEVER Use These Patterns (ReDoS Vulnerable)**
```ts
// ❌ VULNERABLE - Catastrophic backtracking
/.*#(\d+).*/                    // Can cause exponential runtime
/^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/  // Multiple backtracking issues
/.*\d+.*/                       // Greedy quantifiers with overlapping patterns
/(a+)+/                         // Nested quantifiers (evil regex)
/(a|aa)*/                       // Exponential backtracking
```

### **ALWAYS Use These Secure Alternatives**
```ts
// ✅ SECURE - Linear runtime guaranteed
/#(\d+)/                        // Direct match, no backtracking
/^(\w+)(?:\(([^)]+)\))?(!)?:\s*([^\r\n]+?)\s*$/  // Fixed version
/\d+/                           // Simple, direct match
/a+/                            // Single quantifier
/(?:a|aa)*/                     // Non-capturing, optimized
```

## 🛡️ Input Validation & Sanitization

```ts
// Always validate user input
const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password: string): boolean => {
  // At least 8 characters, 1 uppercase, 1 lowercase, 1 number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
};

// Sanitize user input to prevent XSS
const sanitizeHtml = (html: string): string => {
  return html
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
};

// Input validation with sanitization
const processInput = (input: string) => {
  // Validate input length to prevent DoS
  if (input.length > 1000) {
    throw new Error('Input too long');
  }
  
  // Sanitize input to remove potentially dangerous characters
  const sanitized = input.replace(/[^\w\s#]/g, '');
  
  return sanitized;
};
```

## 🔐 Environment Variables & Configuration

```ts
// Use environment variables for sensitive data
const API_KEY = process.env.API_KEY;
const DATABASE_URL = process.env.DATABASE_URL;
const JWT_SECRET = process.env.JWT_SECRET;

// Validate required environment variables
if (!API_KEY) {
  throw new Error('API_KEY is required');
}

if (!DATABASE_URL) {
  throw new Error('DATABASE_URL is required');
}

if (!JWT_SECRET) {
  throw new Error('JWT_SECRET is required');
}
```

## 🔑 Authentication & Authorization

```ts
// Use JWT tokens for authentication
const authenticate = async (token: string) => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Implement token refresh
const refreshToken = async (refreshToken: string) => {
  try {
    const response = await api.post('/auth/refresh', { refreshToken });
    return response.data.accessToken;
  } catch (error) {
    throw new Error('Token refresh failed');
  }
};

// Set execution timeouts for regex operations
const safeRegexTest = async (pattern: RegExp, input: string): Promise<boolean> => {
  return await Promise.race([
    Promise.resolve(pattern.test(input)),
    new Promise<boolean>((_, reject) => 
      setTimeout(() => reject(new Error('Regex timeout')), 1000)
    )
  ]);
};
```

## 🚧 Rate Limiting & CORS

```ts
// Implement rate limiting
const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});

app.use('/api/', rateLimiter);

// Configure CORS properly
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

## 🛡️ SQL Injection Prevention

```ts
// Use parameterized queries
const getUserById = async (id: number) => {
  const query = 'SELECT * FROM users WHERE id = ?';
  const result = await db.execute(query, [id]);
  return result[0];
};

// ❌ Bad - vulnerable to SQL injection
const badQuery = `SELECT * FROM users WHERE id = ${userId}`;

// ✅ Good - parameterized query
const goodQuery = 'SELECT * FROM users WHERE id = ?';
```

## 🎯 Regex Security Best Practices

### **Avoid Greedy Quantifiers with Overlapping Patterns**
```ts
// ❌ Bad - Can cause backtracking
const badPattern = /.*#\d+.*/;

// ✅ Good - Direct match
const goodPattern = /#\d+/;
```

### **Use Non-Capturing Groups When Possible**
```ts
// ❌ Bad - Capturing group overhead
const badPattern = /(\w+)(\([^)]+\))/;

// ✅ Good - Non-capturing group
const goodPattern = /(\w+)(?:\([^)]+\))/;
```

### **Limit Quantifier Ranges**
```ts
// ❌ Bad - Unbounded range
const badPattern = /\d+/;

// ✅ Good - Bounded range
const goodPattern = /\d{1,10}/;
```

### **Use Anchors to Prevent Unnecessary Matching**
```ts
// ❌ Bad - Can match anywhere in string
const badPattern = /#\d+/;

// ✅ Good - Anchored to start/end
const goodPattern = /^#\d+$/;
```

## 🔍 Security Checklist

Before deploying any code, verify:

- [ ] **No nested quantifiers** like `(a+)+`
- [ ] **No greedy + lazy combinations** like `.*+?`
- [ ] **No overlapping patterns** that can backtrack
- [ ] **Use bounded quantifiers** when possible
- [ ] **Test with malicious input** like repeated characters
- [ ] **Consider input length limits** to prevent DoS
- [ ] **Use atomic groups** `(?>...)` to prevent backtracking
- [ ] **Set execution timeouts** for regex operations
- [ ] **Validate and sanitize input** before processing
- [ ] **Test with edge cases** and various input types
- [ ] **All sensitive data in environment variables**
- [ ] **Proper CORS configuration**
- [ ] **Rate limiting implemented**
- [ ] **SQL injection prevention**
- [ ] **XSS protection in place**

## 🧪 Security Testing

### **Test with Malicious Input**
```ts
// Test patterns with these inputs to detect ReDoS
const maliciousInputs = [
  'a'.repeat(1000) + 'b',           // Tests (a+)+ patterns
  '#1' + '0'.repeat(1000),          // Tests #\d+ patterns
  'a'.repeat(1000) + '!',           // Tests .* patterns
];

// If any test takes >100ms, the regex is vulnerable
```

### **Use Regex Safety Tools**
```bash
# Install safe-regex for Node.js
npm install safe-regex

# Use in code
import safeRegex from 'safe-regex';
const isSafe = safeRegex(/your-regex-pattern/);
```

## 📚 Resources

- [OWASP ReDoS Prevention](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)
- [Safe Regex Testing](https://github.com/davisjam/safe-regex)
- [Regex Performance](https://www.regular-expressions.info/performance.html)

---

**Remember**: When in doubt, prefer simple string methods over complex regex patterns. Security and performance are more important than elegant regex solutions.