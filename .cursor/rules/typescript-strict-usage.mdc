---
description: Use strict TypeScript practices for type safety
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

Use strict TypeScript practices for maximum type safety.

## Type Safety

```ts
// ✅ Good - explicit types
const user: User = {
  id: 1,
  name: "John Doe",
  email: "john@example.com"
};

// ❌ Bad - avoid any type
const data: any = fetchData();

// ✅ Good - proper typing
const data: ApiResponse = fetchData();
```

## Interface Definitions

```ts
// Define clear interfaces
interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

// Use generics for reusable components
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}
```

## Type Guards

```ts
// Use type guards for runtime type checking
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'email' in obj
  );
}
```

## Explicit Return Types

```ts
// ✅ Good - explicit return type
function getUser(id: number): Promise<User | null> {
  return fetchUser(id);
}

// ✅ Good - explicit async return type
async function createUser(data: CreateUserData): Promise<User> {
  const response = await api.post('/users', data);
  return response.data;
}
```

## Union Types

```ts
// Use union types for finite options
type ButtonVariant = 'primary' | 'secondary' | 'danger';
type ButtonSize = 'small' | 'medium' | 'large';

interface ButtonProps {
  variant: ButtonVariant;
  size: ButtonSize;
  disabled?: boolean;
}
```

## Utility Types

```ts
// Use utility types for type transformations
type PartialUser = Partial<User>;
type UserWithoutId = Omit<User, 'id'>;
type UserKeys = keyof User;
type UserValues = User[UserKeys];
```
