#!/usr/bin/env bun

import { $ } from "bun";
import { colorify } from "./shell/colorify";
import { createScript, validators } from "./shell/create-scripts";

const issuePatterns = [
	{
		filePattern: [/\.vscode\/.*/, /coverage\/.*/, /dist\/.*/, /node_modules\/.*/, /\.env/, /\.act/],
		description: "development files should not be manually committed",
	},
	{
		filePattern: [/CHANGELOG.md/],
		contentPattern: [
			/^# @repo\/[^/]+$/m, // Manual package name headers
			/^## \[[^\]]+\] - \d{4}-\d{2}-\d{2}$/m, // Manual version headers
			/^- [^-]/m, // Manual bullet points that don't start with "- -"
		],
		description: "CHANGELOG.md should be auto-generated by 'bun run version:commit'",
	},
	{
		filePattern: [/package.json/],
		contentPattern: [
			/^[+-]\s*"version":\s*"[^"]+"/, // Manual version changes (only actual diff lines with +/-)
		],
		ignore: {
			mode: "create",
		},
		description: "package.json version should be auto-generated by 'bun run version:commit'",
	},
];

async function findIssues(filePath: string, patterns: typeof issuePatterns): Promise<string[]> {
	const issues: string[] = [];

	for (const pattern of patterns) {
		const fileNameMatches = pattern.filePattern.some((p) => p.test(filePath));

		if (!fileNameMatches) continue;

		const stagedDiff = await $`git diff --cached -- ${filePath}`.text();
		const contentMatches = pattern.contentPattern?.some((p) => p.test(stagedDiff)) ?? true;

		// Check if this is a new file and should be ignored
		const isNewFile = stagedDiff.includes("new file mode") || stagedDiff.includes("--- /dev/null");
		const shouldIgnore = pattern.ignore?.mode === "create" && isNewFile;

		if (contentMatches && !shouldIgnore) {
			issues.push(`${filePath}: ${pattern.description}`);
		}
	}

	return issues;
}

async function checkGitStatus(): Promise<{ stagedFiles: string[] }> {
	const status = await $`git status --porcelain`.text();
	const lines = status.split("\n").filter(Boolean);

	return {
		stagedFiles: lines
			.filter((line) => line.startsWith("A ") || line.startsWith("M "))
			.map((line) => line.substring(3)),
	};
}

const scriptConfig = {
	name: "Commit Staged Check",
	description: "Validate staged files to prevent manual changes to auto-generated files",
	usage: "bun run commit-staged-check [options]",
	examples: [
		"bun run commit-staged-check",
		"bun run commit-staged-check --verbose",
		"bun run commit-staged-check --staged-only",
	],
	options: [
		{
			short: "-s",
			long: "--staged-only",
			description: "Only check staged files",
			required: false,
			defaultValue: false,
			validator: validators.boolean,
		},
	],
} as const;

export const commitStagedCheck = createScript(scriptConfig, async (_args, xConsole) => {
	try {
		xConsole.log(colorify.blue("üîç Checking staged files for policy violations..."));

		const { stagedFiles } = await checkGitStatus();

		if (!stagedFiles.length) {
			xConsole.log(colorify.green("‚úÖ No staged changes"));
			return;
		}

		xConsole.log(
			colorify.gray(`Found ${stagedFiles.length} staged files: ${stagedFiles.join(", ")}`),
		);

		const allIssues = await Promise.all(
			stagedFiles.map(async (file) => await findIssues(file, issuePatterns)),
		).then((issues) => issues.flat());

		if (allIssues.length === 0) {
			xConsole.log(colorify.green("‚úÖ No policy violations found in staged files"));
			return;
		}

		xConsole.error(colorify.red("‚ùå Policy violations found:"));
		for (const issue of allIssues) {
			xConsole.error(colorify.red(`  ‚Ä¢ ${issue}`));
		}

		xConsole.error(colorify.yellow("\nüí° To fix these issues:"));
		xConsole.error(
			colorify.yellow("  ‚Ä¢ Use 'bun run version:commit' for version and changelog updates"),
		);
		xConsole.error(colorify.yellow("  ‚Ä¢ Avoid committing development files manually"));
		xConsole.error(
			colorify.yellow("  ‚Ä¢ Let automation handle package.json and CHANGELOG.md updates"),
		);

		process.exit(1);
	} catch (error) {
		xConsole.error(
			colorify.red(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`),
		);
		process.exit(1);
	}
});

if (import.meta.main) {
	commitStagedCheck();
}
