#!/usr/bin/env bun
import { $ } from "bun";
import { colorify } from "./shell/colorify";
import { createScript, type ScriptConfig, validators } from "./shell/create-scripts";

const issuePatterns = [
	{
		filePattern: [/\.vscode\/.*/, /coverage\/.*/, /dist\/.*/, /node_modules\/.*/, /\.env/, /\.act/],
		description: "development files should not be manually committed",
	},
	{
		filePattern: [/CHANGELOG.md/],
		contentPattern: [
			/^# @repo\/[^/]+$/m, // Manual package name headers
			/^## \[[^\]]+\] - \d{4}-\d{2}-\d{2}$/m, // Manual version headers
			/^- [^-]/m, // Manual bullet points that don't start with "- -"
		],
		description: "CHANGELOG.md should be auto-generated by 'bun run version:commit'",
	},
	{
		filePattern: [/package.json/],
		contentPattern: [
			/"version": "[^"]+"/, // Manual version changes
		],
		ignore: {
			mode: "create",
		},
		description: "package.json version should be auto-generated by 'bun run version:commit'",
	},
];

async function findIssues(filePath: string, patterns: typeof issuePatterns): Promise<string[]> {
	const issues: string[] = [];

	for (const pattern of patterns) {
		const fileNameMatches = pattern.filePattern.some((p) => p.test(filePath));

		if (!fileNameMatches) continue;

		const stagedDiff = await $`git diff --cached -- ${filePath}`.text();
		const contentMatches = pattern.contentPattern?.some((p) => p.test(stagedDiff)) ?? true;

		// Check if this is a new file and should be ignored
		const isNewFile = stagedDiff.includes("new file mode") || stagedDiff.includes("--- /dev/null");
		const shouldIgnore = pattern.ignore?.mode === "create" && isNewFile;

		if (contentMatches && !shouldIgnore) {
			issues.push(`${filePath}: ${pattern.description}`);
		}
	}

	return issues;
}

async function checkGitStatus(): Promise<{ stagedFiles: string[] }> {
	const status = await $`git status --porcelain`.text();
	const lines = status.split("\n").filter(Boolean);

	return {
		stagedFiles: lines
			.filter((line) => line.startsWith("A ") || line.startsWith("M "))
			.map((line) => line.substring(3)),
	};
}

export const checkStagedFiles = createScript(
	{
		name: "Check Staged Files",
		description: "Check for manual changes to staged files",
		usage: "bun run check:staged",
		examples: ["bun run check:staged"],
		options: [
			{
				short: "-s",
				long: "--staged-only",
				description: "Only check staged files",
				required: false,
				defaultValue: false,
				validator: validators.boolean,
			},
		],
	} as const satisfies ScriptConfig,
	async function main(_, xConsole) {
		xConsole.info("üîç Checking for issues in staged files...");

		const { stagedFiles } = await checkGitStatus();

		if (!stagedFiles.length) {
			xConsole.info("‚úÖ No staged changes");
			return;
		}

		const allIssues = await Promise.all(
			stagedFiles.map(async (file) => await findIssues(file, issuePatterns)),
		).then((issues) => issues.flat());

		if (allIssues.length === 0) {
			xConsole.info("‚úÖ No custom issues found in staged files");
			return;
		}

		for (const issue of allIssues) {
			xConsole.error(colorify.red(`‚ùå ${issue}`));
		}
		process.exit(1);
	},
);

if (import.meta.main) {
	checkStagedFiles();
}
